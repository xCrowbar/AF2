{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createAsyncMiddleware = void 0;\n/**\n * JsonRpcEngine only accepts callback-based middleware directly.\n * createAsyncMiddleware exists to enable consumers to pass in async middleware\n * functions.\n *\n * Async middleware have no \"end\" function. Instead, they \"end\" if they return\n * without calling \"next\". Rather than passing in explicit return handlers,\n * async middleware can simply await \"next\", and perform operations on the\n * response object when execution resumes.\n *\n * To accomplish this, createAsyncMiddleware passes the async middleware a\n * wrapped \"next\" function. That function calls the internal JsonRpcEngine\n * \"next\" function with a return handler that resolves a promise when called.\n *\n * The return handler will always be called. Its resolution of the promise\n * enables the control flow described above.\n */\n\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return async (req, res, next, end) => {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise;\n    const nextPromise = new Promise(resolve => {\n      resolveNextPromise = resolve;\n    });\n    let returnHandlerCallback = null;\n    let nextWasCalled = false; // This will be called by the consumer's async middleware.\n\n    const asyncNext = async () => {\n      nextWasCalled = true; // We pass a return handler to next(). When it is called by the engine,\n      // the consumer's async middleware will resume executing.\n      // eslint-disable-next-line node/callback-return\n\n      next(runReturnHandlersCallback => {\n        // This callback comes from JsonRpcEngine._runReturnHandlers\n        returnHandlerCallback = runReturnHandlersCallback;\n        resolveNextPromise();\n      });\n      await nextPromise;\n    };\n\n    try {\n      await asyncMiddleware(req, res, asyncNext);\n\n      if (nextWasCalled) {\n        await nextPromise; // we must wait until the return handler is called\n\n        returnHandlerCallback(null);\n      } else {\n        end(null);\n      }\n    } catch (error) {\n      if (returnHandlerCallback) {\n        returnHandlerCallback(error);\n      } else {\n        end(error);\n      }\n    }\n  };\n}\n\nexports.createAsyncMiddleware = createAsyncMiddleware;","map":{"version":3,"mappings":";;;;;;AAgBA;;;;;;;;;;;;;;;;;;AAiBA,SAAgBA,qBAAhB,CACEC,eADF,EAC+C;AAE7C,SAAO,OAAOC,GAAP,EAAYC,GAAZ,EAAiBC,IAAjB,EAAuBC,GAAvB,KAA8B;AACnC;AACA;AACA;AACA,QAAIC,kBAAJ;AACA,UAAMC,WAAW,GAAG,IAAIC,OAAJ,CAAaC,OAAD,IAAY;AAC1CH,wBAAkB,GAAGG,OAArB;AACD,KAFmB,CAApB;AAIA,QAAIC,qBAAqB,GAAY,IAArC;AACA,QAAIC,aAAa,GAAG,KAApB,CAVmC,CAYnC;;AACA,UAAMC,SAAS,GAAG,YAAW;AAC3BD,mBAAa,GAAG,IAAhB,CAD2B,CAG3B;AACA;AACA;;AACAP,UAAI,CAAES,yBAAD,IAA8B;AACjC;AACAH,6BAAqB,GAAGG,yBAAxB;AACAP,0BAAkB;AACnB,OAJG,CAAJ;AAKA,YAAMC,WAAN;AACD,KAZD;;AAcA,QAAI;AACF,YAAMN,eAAe,CAACC,GAAD,EAAMC,GAAN,EAAWS,SAAX,CAArB;;AAEA,UAAID,aAAJ,EAAmB;AACjB,cAAMJ,WAAN,CADiB,CACE;;AAClBG,6BAA+C,CAAC,IAAD,CAA/C;AACF,OAHD,MAGO;AACLL,WAAG,CAAC,IAAD,CAAH;AACD;AACF,KATD,CASE,OAAOS,KAAP,EAAc;AACd,UAAIJ,qBAAJ,EAA2B;AACxBA,6BAA+C,CAACI,KAAD,CAA/C;AACF,OAFD,MAEO;AACLT,WAAG,CAACS,KAAD,CAAH;AACD;AACF;AACF,GA3CD;AA4CD;;AA/CDC","names":["createAsyncMiddleware","asyncMiddleware","req","res","next","end","resolveNextPromise","nextPromise","Promise","resolve","returnHandlerCallback","nextWasCalled","asyncNext","runReturnHandlersCallback","error","exports"],"sourceRoot":"","sources":["../src/createAsyncMiddleware.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}