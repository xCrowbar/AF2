{"ast":null,"code":"import { createTypedEmitter } from './events';\nvar promiEventBrand = Symbol('isPromiEvent');\n/**\n * Returns `true` if the given `value` is a `PromiEvent`.\n */\n\nexport function isPromiEvent(value) {\n  return !!value[promiEventBrand];\n}\n/**\n * Create a native JavaScript `Promise` overloaded with strongly-typed methods\n * from `EventEmitter`.\n */\n\nexport function createPromiEvent(executor) {\n  var promise = createAutoCatchingPromise(executor);\n\n  var _a = createTypedEmitter(),\n      createBoundEmitterMethod = _a.createBoundEmitterMethod,\n      createChainingEmitterMethod = _a.createChainingEmitterMethod; // We save the original `Promise` methods to the following symbols so we can\n  // access them internally.\n\n\n  var thenSymbol = Symbol('Promise.then');\n  var catchSymbol = Symbol('Promise.catch');\n  var finallySymbol = Symbol('Promise.finally');\n  /**\n   * Ensures the next object in the `PromiEvent` chain is overloaded with\n   * `EventEmitter` methods.\n   */\n\n  var createChainingPromiseMethod = function (method, source) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var nextPromise = source[method].apply(source, args);\n      return promiEvent(nextPromise);\n    };\n  };\n  /**\n   * Builds a `PromiEvent` by assigning `EventEmitter` methods to a native\n   * `Promise` object.\n   */\n\n\n  var promiEvent = function (source) {\n    var _a;\n\n    return Object.assign(source, (_a = {}, _a[promiEventBrand] = true, _a[thenSymbol] = source[thenSymbol] || source.then, _a[catchSymbol] = source[catchSymbol] || source.catch, _a[finallySymbol] = source[finallySymbol] || source.finally, _a.then = createChainingPromiseMethod(thenSymbol, source), _a.catch = createChainingPromiseMethod(catchSymbol, source), _a.finally = createChainingPromiseMethod(finallySymbol, source), _a.on = createChainingEmitterMethod('on', source), _a.once = createChainingEmitterMethod('once', source), _a.addListener = createChainingEmitterMethod('addListener', source), _a.off = createChainingEmitterMethod('off', source), _a.removeListener = createChainingEmitterMethod('removeListener', source), _a.removeAllListeners = createChainingEmitterMethod('removeAllListeners', source), _a.emit = createBoundEmitterMethod('emit'), _a.eventNames = createBoundEmitterMethod('eventNames'), _a.listeners = createBoundEmitterMethod('listeners'), _a.listenerCount = createBoundEmitterMethod('listenerCount'), _a));\n  };\n\n  var result = promiEvent(promise.then(function (resolved) {\n    // Emit default completion events and resolve result.\n    result.emit('done', resolved);\n    result.emit('settled');\n    return resolved;\n  }, function (err) {\n    // Emit default error events and re-throw.\n    result.emit('error', err);\n    result.emit('settled');\n    throw err;\n  }));\n  return result;\n}\n/**\n * Creates a `Promise` with an **async executor** that automatically catches\n * errors occurring within the executor. Nesting promises in this way is usually\n * deemed an _anti-pattern_, but it's useful and clean when promisifying the\n * event-based code that's inherent to JSON RPC.\n *\n * So, here we solve the issue of nested promises by ensuring that no errors\n * mistakenly go unhandled!\n */\n\nexport function createAutoCatchingPromise(executor) {\n  return new Promise(function (resolve, reject) {\n    var result = executor(resolve, reject);\n    Promise.resolve(result).catch(reject);\n  });\n}","map":{"version":3,"mappings":"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","names":["createTypedEmitter","promiEventBrand","Symbol","isPromiEvent","value","createPromiEvent","executor","promise","createAutoCatchingPromise","createBoundEmitterMethod","createChainingEmitterMethod","thenSymbol","catchSymbol","finallySymbol","createChainingPromiseMethod","method","source","args","nextPromise","apply","promiEvent","Object","assign","_a","then","catch","finally","result","resolved","emit","err","Promise","resolve","reject"],"sourceRoot":"","sources":["../../../src/util/promise-tools.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}