{"ast":null,"code":"'use strict';\n\nvar THREE = require('three'); //\n// STL Loader added\n//\n\n/**\n * @author aleeper / http://adamleeper.com/\n * @author mrdoob / http://mrdoob.com/\n * @author gero3 / https://github.com/gero3\n *\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8. Seems to work for the examples...\n *\n * Usage:\n *  var loader = new THREE.STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n */\n\n\nTHREE.STLLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTHREE.STLLoader.prototype = {\n  constructor: THREE.STLLoader,\n  loadFromUrl: function loadFromUrl(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new THREE.XHRLoader(scope.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (text) {\n      onLoad(scope.parse(text));\n    }, onProgress, onError);\n  },\n  loadFromFile: function loadFromFile(buffer, onLoad) {\n    var scope = this;\n    onLoad(scope.parse(buffer));\n  },\n  parse: function parse(data) {\n    var isBinary = function isBinary() {\n      var expect, face_size, n_faces, reader;\n      reader = new DataView(binData);\n      face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n      n_faces = reader.getUint32(80, true);\n      expect = 80 + 32 / 8 + n_faces * face_size;\n\n      if (expect === reader.byteLength) {\n        return true;\n      } // some binary files will have different size from expected,\n      // checking characters higher than ASCII to confirm is binary\n\n\n      var fileLength = reader.byteLength;\n\n      for (var index = 0; index < fileLength; index++) {\n        if (reader.getUint8(index, false) > 127) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    var binData = this.ensureBinary(data);\n    return isBinary() ? this.parseBinary(binData) : this.parseASCII(this.ensureString(data));\n  },\n  parseBinary: function parseBinary(data) {\n    var reader = new DataView(data);\n    var faces = reader.getUint32(80, true);\n    var r,\n        g,\n        b,\n        hasColors = false,\n        colors;\n    var defaultR, defaultG, defaultB, alpha; // process STL header\n    // check for default color in header (\"COLOR=rgba\" sequence).\n\n    for (var index = 0; index < 80 - 10; index++) {\n      if (reader.getUint32(index, false) == 0x434f4c4f\n      /*COLO*/\n      && reader.getUint8(index + 4) == 0x52\n      /*'R'*/\n      && reader.getUint8(index + 5) == 0x3d\n      /*'='*/\n      ) {\n        hasColors = true;\n        colors = new Float32Array(faces * 3 * 3);\n        defaultR = reader.getUint8(index + 6) / 255;\n        defaultG = reader.getUint8(index + 7) / 255;\n        defaultB = reader.getUint8(index + 8) / 255;\n        alpha = reader.getUint8(index + 9) / 255;\n      }\n    }\n\n    var dataOffset = 84;\n    var faceLength = 12 * 4 + 2;\n    var offset = 0;\n    var geometry = new THREE.BufferGeometry();\n    var vertices = new Float32Array(faces * 3 * 3);\n    var normals = new Float32Array(faces * 3 * 3);\n\n    for (var face = 0; face < faces; face++) {\n      var start = dataOffset + face * faceLength;\n      var normalX = reader.getFloat32(start, true);\n      var normalY = reader.getFloat32(start + 4, true);\n      var normalZ = reader.getFloat32(start + 8, true);\n\n      if (hasColors) {\n        var packedColor = reader.getUint16(start + 48, true);\n\n        if ((packedColor & 0x8000) === 0) {\n          // facet has its own unique color\n          r = (packedColor & 0x1f) / 31;\n          g = (packedColor >> 5 & 0x1f) / 31;\n          b = (packedColor >> 10 & 0x1f) / 31;\n        } else {\n          r = defaultR;\n          g = defaultG;\n          b = defaultB;\n        }\n      }\n\n      for (var i = 1; i <= 3; i++) {\n        var vertexstart = start + i * 12;\n        vertices[offset] = reader.getFloat32(vertexstart, true);\n        vertices[offset + 1] = reader.getFloat32(vertexstart + 4, true);\n        vertices[offset + 2] = reader.getFloat32(vertexstart + 8, true);\n        normals[offset] = normalX;\n        normals[offset + 1] = normalY;\n        normals[offset + 2] = normalZ;\n\n        if (hasColors) {\n          colors[offset] = r;\n          colors[offset + 1] = g;\n          colors[offset + 2] = b;\n        }\n\n        offset += 3;\n      }\n    }\n\n    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n    geometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n\n    if (hasColors) {\n      geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));\n      geometry.hasColors = true;\n      geometry.alpha = alpha;\n    }\n\n    return geometry;\n  },\n  parseASCII: function parseASCII(data) {\n    var geometry, length, normal, patternFace, patternNormal, patternVertex, result, text;\n    geometry = new THREE.Geometry();\n    patternFace = /facet([\\s\\S]*?)endfacet/g;\n\n    while ((result = patternFace.exec(data)) !== null) {\n      text = result[0];\n      patternNormal = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n      while ((result = patternNormal.exec(text)) !== null) {\n        normal = new THREE.Vector3(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));\n      }\n\n      patternVertex = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n      while ((result = patternVertex.exec(text)) !== null) {\n        geometry.vertices.push(new THREE.Vector3(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5])));\n      }\n\n      length = geometry.vertices.length;\n      geometry.faces.push(new THREE.Face3(length - 3, length - 2, length - 1, normal));\n    }\n\n    geometry.computeBoundingBox();\n    geometry.computeBoundingSphere();\n    return geometry;\n  },\n  ensureString: function ensureString(buf) {\n    if (typeof buf !== 'string') {\n      var array_buffer = new Uint8Array(buf);\n      var str = '';\n\n      for (var i = 0; i < buf.byteLength; i++) {\n        str += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\n      }\n\n      return str;\n    } else {\n      return buf;\n    }\n  },\n  ensureBinary: function ensureBinary(buf) {\n    if (typeof buf === 'string') {\n      var array_buffer = new Uint8Array(buf.length);\n\n      for (var i = 0; i < buf.length; i++) {\n        array_buffer[i] = buf.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n      }\n\n      return array_buffer.buffer || array_buffer;\n    } else {\n      return buf;\n    }\n  }\n};\n\nif (typeof DataView === 'undefined') {\n  DataView = function DataView(buffer, byteOffset, byteLength) {\n    this.buffer = buffer;\n    this.byteOffset = byteOffset || 0;\n    this.byteLength = byteLength || buffer.byteLength || buffer.length;\n    this._isString = typeof buffer === 'string';\n  };\n\n  DataView.prototype = {\n    _getCharCodes: function _getCharCodes(buffer, start, length) {\n      start = start || 0;\n      length = length || buffer.length;\n      var end = start + length;\n      var codes = [];\n\n      for (var i = start; i < end; i++) {\n        codes.push(buffer.charCodeAt(i) & 0xff);\n      }\n\n      return codes;\n    },\n    _getBytes: function _getBytes(length, byteOffset, littleEndian) {\n      var result; // Handle the lack of endianness\n\n      if (littleEndian === undefined) {\n        littleEndian = this._littleEndian;\n      } // Handle the lack of byteOffset\n\n\n      if (byteOffset === undefined) {\n        byteOffset = this.byteOffset;\n      } else {\n        byteOffset = this.byteOffset + byteOffset;\n      }\n\n      if (length === undefined) {\n        length = this.byteLength - byteOffset;\n      } // Error Checking\n\n\n      if (typeof byteOffset !== 'number') {\n        throw new TypeError('DataView byteOffset is not a number');\n      }\n\n      if (length < 0 || byteOffset + length > this.byteLength) {\n        throw new Error('DataView length or (byteOffset+length) value is out of bounds');\n      }\n\n      if (this.isString) {\n        result = this._getCharCodes(this.buffer, byteOffset, byteOffset + length);\n      } else {\n        result = this.buffer.slice(byteOffset, byteOffset + length);\n      }\n\n      if (!littleEndian && length > 1) {\n        if (!(result instanceof Array)) {\n          result = Array.prototype.slice.call(result);\n        }\n\n        result.reverse();\n      }\n\n      return result;\n    },\n    // Compatibility functions on a String Buffer\n    getFloat64: function getFloat64(byteOffset, littleEndian) {\n      var b = this._getBytes(8, byteOffset, littleEndian),\n          sign = 1 - 2 * (b[7] >> 7),\n          exponent = ((b[7] << 1 & 0xff) << 3 | b[6] >> 4) - ((1 << 10) - 1),\n          // Binary operators such as | and << operate on 32 bit values, using + and Math.pow(2) instead\n      mantissa = (b[6] & 0x0f) * Math.pow(2, 48) + b[5] * Math.pow(2, 40) + b[4] * Math.pow(2, 32) + b[3] * Math.pow(2, 24) + b[2] * Math.pow(2, 16) + b[1] * Math.pow(2, 8) + b[0];\n\n      if (exponent === 1024) {\n        if (mantissa !== 0) {\n          return NaN;\n        } else {\n          return sign * Infinity;\n        }\n      }\n\n      if (exponent === -1023) {\n        // Denormalized\n        return sign * mantissa * Math.pow(2, -1022 - 52);\n      }\n\n      return sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);\n    },\n    getFloat32: function getFloat32(byteOffset, littleEndian) {\n      var b = this._getBytes(4, byteOffset, littleEndian),\n          sign = 1 - 2 * (b[3] >> 7),\n          exponent = (b[3] << 1 & 0xff | b[2] >> 7) - 127,\n          mantissa = (b[2] & 0x7f) << 16 | b[1] << 8 | b[0];\n\n      if (exponent === 128) {\n        if (mantissa !== 0) {\n          return NaN;\n        } else {\n          return sign * Infinity;\n        }\n      }\n\n      if (exponent === -127) {\n        // Denormalized\n        return sign * mantissa * Math.pow(2, -126 - 23);\n      }\n\n      return sign * (1 + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);\n    },\n    getInt32: function getInt32(byteOffset, littleEndian) {\n      var b = this._getBytes(4, byteOffset, littleEndian);\n\n      return b[3] << 24 | b[2] << 16 | b[1] << 8 | b[0];\n    },\n    getUint32: function getUint32(byteOffset, littleEndian) {\n      return this.getInt32(byteOffset, littleEndian) >>> 0;\n    },\n    getInt16: function getInt16(byteOffset, littleEndian) {\n      return this.getUint16(byteOffset, littleEndian) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset, littleEndian) {\n      var b = this._getBytes(2, byteOffset, littleEndian);\n\n      return b[1] << 8 | b[0];\n    },\n    getInt8: function getInt8(byteOffset) {\n      return this.getUint8(byteOffset) << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return this._getBytes(1, byteOffset)[0];\n    }\n  };\n}\n\nmodule.exports = THREE;","map":{"version":3,"sources":["/home/mike/Scrivania/provaFrontEnd/af2_front_end_test/node_modules/stl-viewer/dist/Three.js"],"names":["THREE","require","STLLoader","manager","undefined","DefaultLoadingManager","prototype","constructor","loadFromUrl","url","onLoad","onProgress","onError","scope","loader","XHRLoader","setCrossOrigin","crossOrigin","setResponseType","load","text","parse","loadFromFile","buffer","data","isBinary","expect","face_size","n_faces","reader","DataView","binData","getUint32","byteLength","fileLength","index","getUint8","ensureBinary","parseBinary","parseASCII","ensureString","faces","r","g","b","hasColors","colors","defaultR","defaultG","defaultB","alpha","Float32Array","dataOffset","faceLength","offset","geometry","BufferGeometry","vertices","normals","face","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","i","vertexstart","addAttribute","BufferAttribute","length","normal","patternFace","patternNormal","patternVertex","result","Geometry","exec","Vector3","parseFloat","push","Face3","computeBoundingBox","computeBoundingSphere","buf","array_buffer","Uint8Array","str","String","fromCharCode","charCodeAt","byteOffset","_isString","_getCharCodes","end","codes","_getBytes","littleEndian","_littleEndian","TypeError","Error","isString","slice","Array","call","reverse","getFloat64","sign","exponent","mantissa","Math","pow","NaN","Infinity","getInt32","getInt16","getInt8","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar THREE = require('three');\n\n//\n// STL Loader added\n//\n/**\n * @author aleeper / http://adamleeper.com/\n * @author mrdoob / http://mrdoob.com/\n * @author gero3 / https://github.com/gero3\n *\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8. Seems to work for the examples...\n *\n * Usage:\n *  var loader = new THREE.STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n */\n\nTHREE.STLLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTHREE.STLLoader.prototype = {\n  constructor: THREE.STLLoader,\n\n  loadFromUrl: function loadFromUrl(url, onLoad, onProgress, onError) {\n    var scope = this;\n\n    var loader = new THREE.XHRLoader(scope.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (text) {\n      onLoad(scope.parse(text));\n    }, onProgress, onError);\n  },\n\n  loadFromFile: function loadFromFile(buffer, onLoad) {\n    var scope = this;\n    onLoad(scope.parse(buffer));\n  },\n\n  parse: function parse(data) {\n    var isBinary = function isBinary() {\n      var expect, face_size, n_faces, reader;\n      reader = new DataView(binData);\n      face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n      n_faces = reader.getUint32(80, true);\n      expect = 80 + 32 / 8 + n_faces * face_size;\n\n      if (expect === reader.byteLength) {\n        return true;\n      }\n\n      // some binary files will have different size from expected,\n      // checking characters higher than ASCII to confirm is binary\n      var fileLength = reader.byteLength;\n      for (var index = 0; index < fileLength; index++) {\n        if (reader.getUint8(index, false) > 127) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    var binData = this.ensureBinary(data);\n\n    return isBinary() ? this.parseBinary(binData) : this.parseASCII(this.ensureString(data));\n  },\n\n  parseBinary: function parseBinary(data) {\n    var reader = new DataView(data);\n    var faces = reader.getUint32(80, true);\n\n    var r,\n        g,\n        b,\n        hasColors = false,\n        colors;\n    var defaultR, defaultG, defaultB, alpha;\n\n    // process STL header\n    // check for default color in header (\"COLOR=rgba\" sequence).\n\n    for (var index = 0; index < 80 - 10; index++) {\n      if (reader.getUint32(index, false) == 0x434f4c4f /*COLO*/ && reader.getUint8(index + 4) == 0x52 /*'R'*/ && reader.getUint8(index + 5) == 0x3d /*'='*/\n      ) {\n          hasColors = true;\n          colors = new Float32Array(faces * 3 * 3);\n\n          defaultR = reader.getUint8(index + 6) / 255;\n          defaultG = reader.getUint8(index + 7) / 255;\n          defaultB = reader.getUint8(index + 8) / 255;\n          alpha = reader.getUint8(index + 9) / 255;\n        }\n    }\n\n    var dataOffset = 84;\n    var faceLength = 12 * 4 + 2;\n\n    var offset = 0;\n\n    var geometry = new THREE.BufferGeometry();\n\n    var vertices = new Float32Array(faces * 3 * 3);\n    var normals = new Float32Array(faces * 3 * 3);\n\n    for (var face = 0; face < faces; face++) {\n      var start = dataOffset + face * faceLength;\n      var normalX = reader.getFloat32(start, true);\n      var normalY = reader.getFloat32(start + 4, true);\n      var normalZ = reader.getFloat32(start + 8, true);\n\n      if (hasColors) {\n        var packedColor = reader.getUint16(start + 48, true);\n\n        if ((packedColor & 0x8000) === 0) {\n          // facet has its own unique color\n\n          r = (packedColor & 0x1f) / 31;\n          g = (packedColor >> 5 & 0x1f) / 31;\n          b = (packedColor >> 10 & 0x1f) / 31;\n        } else {\n          r = defaultR;\n          g = defaultG;\n          b = defaultB;\n        }\n      }\n\n      for (var i = 1; i <= 3; i++) {\n        var vertexstart = start + i * 12;\n\n        vertices[offset] = reader.getFloat32(vertexstart, true);\n        vertices[offset + 1] = reader.getFloat32(vertexstart + 4, true);\n        vertices[offset + 2] = reader.getFloat32(vertexstart + 8, true);\n\n        normals[offset] = normalX;\n        normals[offset + 1] = normalY;\n        normals[offset + 2] = normalZ;\n\n        if (hasColors) {\n          colors[offset] = r;\n          colors[offset + 1] = g;\n          colors[offset + 2] = b;\n        }\n\n        offset += 3;\n      }\n    }\n\n    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n    geometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n\n    if (hasColors) {\n      geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));\n      geometry.hasColors = true;\n      geometry.alpha = alpha;\n    }\n\n    return geometry;\n  },\n\n  parseASCII: function parseASCII(data) {\n    var geometry, length, normal, patternFace, patternNormal, patternVertex, result, text;\n    geometry = new THREE.Geometry();\n    patternFace = /facet([\\s\\S]*?)endfacet/g;\n\n    while ((result = patternFace.exec(data)) !== null) {\n      text = result[0];\n      patternNormal = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n      while ((result = patternNormal.exec(text)) !== null) {\n        normal = new THREE.Vector3(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));\n      }\n\n      patternVertex = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n      while ((result = patternVertex.exec(text)) !== null) {\n        geometry.vertices.push(new THREE.Vector3(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5])));\n      }\n\n      length = geometry.vertices.length;\n\n      geometry.faces.push(new THREE.Face3(length - 3, length - 2, length - 1, normal));\n    }\n\n    geometry.computeBoundingBox();\n    geometry.computeBoundingSphere();\n\n    return geometry;\n  },\n\n  ensureString: function ensureString(buf) {\n    if (typeof buf !== 'string') {\n      var array_buffer = new Uint8Array(buf);\n      var str = '';\n      for (var i = 0; i < buf.byteLength; i++) {\n        str += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\n      }\n      return str;\n    } else {\n      return buf;\n    }\n  },\n\n  ensureBinary: function ensureBinary(buf) {\n    if (typeof buf === 'string') {\n      var array_buffer = new Uint8Array(buf.length);\n      for (var i = 0; i < buf.length; i++) {\n        array_buffer[i] = buf.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n      }\n      return array_buffer.buffer || array_buffer;\n    } else {\n      return buf;\n    }\n  }\n};\n\nif (typeof DataView === 'undefined') {\n  DataView = function DataView(buffer, byteOffset, byteLength) {\n    this.buffer = buffer;\n    this.byteOffset = byteOffset || 0;\n    this.byteLength = byteLength || buffer.byteLength || buffer.length;\n    this._isString = typeof buffer === 'string';\n  };\n\n  DataView.prototype = {\n    _getCharCodes: function _getCharCodes(buffer, start, length) {\n      start = start || 0;\n      length = length || buffer.length;\n      var end = start + length;\n      var codes = [];\n      for (var i = start; i < end; i++) {\n        codes.push(buffer.charCodeAt(i) & 0xff);\n      }\n      return codes;\n    },\n\n    _getBytes: function _getBytes(length, byteOffset, littleEndian) {\n      var result;\n\n      // Handle the lack of endianness\n      if (littleEndian === undefined) {\n        littleEndian = this._littleEndian;\n      }\n\n      // Handle the lack of byteOffset\n      if (byteOffset === undefined) {\n        byteOffset = this.byteOffset;\n      } else {\n        byteOffset = this.byteOffset + byteOffset;\n      }\n\n      if (length === undefined) {\n        length = this.byteLength - byteOffset;\n      }\n\n      // Error Checking\n      if (typeof byteOffset !== 'number') {\n        throw new TypeError('DataView byteOffset is not a number');\n      }\n\n      if (length < 0 || byteOffset + length > this.byteLength) {\n        throw new Error('DataView length or (byteOffset+length) value is out of bounds');\n      }\n\n      if (this.isString) {\n        result = this._getCharCodes(this.buffer, byteOffset, byteOffset + length);\n      } else {\n        result = this.buffer.slice(byteOffset, byteOffset + length);\n      }\n\n      if (!littleEndian && length > 1) {\n        if (!(result instanceof Array)) {\n          result = Array.prototype.slice.call(result);\n        }\n\n        result.reverse();\n      }\n\n      return result;\n    },\n\n    // Compatibility functions on a String Buffer\n\n    getFloat64: function getFloat64(byteOffset, littleEndian) {\n      var b = this._getBytes(8, byteOffset, littleEndian),\n          sign = 1 - 2 * (b[7] >> 7),\n          exponent = ((b[7] << 1 & 0xff) << 3 | b[6] >> 4) - ((1 << 10) - 1),\n\n      // Binary operators such as | and << operate on 32 bit values, using + and Math.pow(2) instead\n      mantissa = (b[6] & 0x0f) * Math.pow(2, 48) + b[5] * Math.pow(2, 40) + b[4] * Math.pow(2, 32) + b[3] * Math.pow(2, 24) + b[2] * Math.pow(2, 16) + b[1] * Math.pow(2, 8) + b[0];\n\n      if (exponent === 1024) {\n        if (mantissa !== 0) {\n          return NaN;\n        } else {\n          return sign * Infinity;\n        }\n      }\n\n      if (exponent === -1023) {\n        // Denormalized\n        return sign * mantissa * Math.pow(2, -1022 - 52);\n      }\n\n      return sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);\n    },\n\n    getFloat32: function getFloat32(byteOffset, littleEndian) {\n      var b = this._getBytes(4, byteOffset, littleEndian),\n          sign = 1 - 2 * (b[3] >> 7),\n          exponent = (b[3] << 1 & 0xff | b[2] >> 7) - 127,\n          mantissa = (b[2] & 0x7f) << 16 | b[1] << 8 | b[0];\n\n      if (exponent === 128) {\n        if (mantissa !== 0) {\n          return NaN;\n        } else {\n          return sign * Infinity;\n        }\n      }\n\n      if (exponent === -127) {\n        // Denormalized\n        return sign * mantissa * Math.pow(2, -126 - 23);\n      }\n\n      return sign * (1 + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);\n    },\n\n    getInt32: function getInt32(byteOffset, littleEndian) {\n      var b = this._getBytes(4, byteOffset, littleEndian);\n      return b[3] << 24 | b[2] << 16 | b[1] << 8 | b[0];\n    },\n\n    getUint32: function getUint32(byteOffset, littleEndian) {\n      return this.getInt32(byteOffset, littleEndian) >>> 0;\n    },\n\n    getInt16: function getInt16(byteOffset, littleEndian) {\n      return this.getUint16(byteOffset, littleEndian) << 16 >> 16;\n    },\n\n    getUint16: function getUint16(byteOffset, littleEndian) {\n      var b = this._getBytes(2, byteOffset, littleEndian);\n      return b[1] << 8 | b[0];\n    },\n\n    getInt8: function getInt8(byteOffset) {\n      return this.getUint8(byteOffset) << 24 >> 24;\n    },\n\n    getUint8: function getUint8(byteOffset) {\n      return this._getBytes(1, byteOffset)[0];\n    }\n  };\n}\n\nmodule.exports = THREE;"]},"metadata":{},"sourceType":"script"}